# Основные принципы Unicode

Есть потребность обмена текстовой информацией. Обмен проиходит между разными платформами, устройствами, программами и языками программирования. Все ли участники обмена воспринимают эту информацию одинаково? Информацию кодируют последовательностью битовых значений: есть сигнал (1) или нет сигнала (0). Биты складываются в байты (8 бит - 1 байт) и их последовательности могут использоваться для кодирования текстового сообщения. Каждая последовательность байт это двоичная запись числа, а число сопоставляется с единицей текста: символом или образом. Есть ещё знаки акцентов для символов, но в целом описание верно.

Есть потребность записывать и передавать текстовые сообщения на разных языках, включая образы, объединённые общей идеей.  Например: изображения Emoji, математические символы, отметки в текстах богослужений (типиконы), записи цифр и велечин (мер) разных народов и многое другое. 

Примеры со сылками содержат вид символа и обстоятельства его появления в юникоде: [Древнеперсидская цифра сто](https://unicode-table.com/ru/103D5/){: target="_blank"}, [Эгейская мера веса](https://unicode-table.com/ru/10137/){: target="_blank"}, 
[Письмо Бернарда Шоу](https://unicode-table.com/ru/blocks/shavian/){: target="_blank"}, [Клинопись](https://unicode-table.com/ru/blocks/cuneiform/){: target="_blank"}.

### Стандарт {: #standart}

Каждому числу (кодовой точке) сопоставляется определённое и только одно символьное значение. Иногда это служебные символы, для которых нет видимого представления: образа. Символы или образы, одного языка или имеющие общую идею (например персидские числа), сопоставлены непересекающимся диапазонам числовых значений. 

Число может не иметь своего символьного представления, но это не значит, что такие числа игнорируют в сообщении. Некоторые символы являются служебными и служат для оформления текста, его направления или других целей. Для каждого числа есть своя роль и искажать эту информацию нельзя.

Не все числовые чиапазоны следуют друг за другом: между ними есть диапазоны не занятые значениями кодовых точек. Это сделано специально, чтобы в будующем иметь резерв для изменения. 

Такое сопоставление назвали кодированием и создали консорциум Unicode, который стремится к выполнению стандарта ISO/IEC 10646: Информационная технология - Универсальный кодированный набор символов (UCS - Universal Coded Character Set). На момент написания статьи есть 6-ая редакция стандарта за декабрь 2020 года из 2814 страниц и стандарт продолжает развиваться: есть упоминание перехода к стандарту 2021 года. В документе есть подробное описание правил и методов для добавления новых кодовых точек.

#### Группа знаков для отображения символа {: #gruppa_znakov_dlya_otobrazheniya_simvola}

Кодовые точки в стандарте Юникод записаны 16-битовыми значениями. Иногда в юникоде символ может быть сопоставлен группе кодовых точек. Группы используют для экономии памяти: с их помощью ставятся ударения, циркумфлексы и другие диакритические знаки под или над символами, и даже внутри символа. Такие комбинации позволяют уменьшить количество кодируемых символов.

Например: 

- Латинская заглавная буква под ударением (Á) это : U+0041 (A) + U+0301 (`) 
- Латинская заглавная буква с циркумфлексом (Û): U+00DB или  U+0055(U) + U+0302(̂)

Ранее созданные единичные символы, например U+00DB, которые могут быть получены с использованием комбинаций, остались в стандарте для совместимости.

### Технические детали {: #tekhnicheskie_detali}

Каждая точка может быть записана как шестнадцатиричное число из диапазона от 0 до 10FFFF. Точки разделены на кодовые плоскости по 65536=2^16^ непрерывных значений в каждой. Всего получается 17 плоскостей, которые нумеруют цифрами от 0 до 16-ти.

Забегая вперёд следует сказать, что кодирование UTF-16 позволяет использовать только 20 бит из доступных и кодировать 2^16^\*2^4^ точек или использовать 17=2^4^+1 плоскостей. Кодирование UTF-8 позволяет использовать до 31 бита из доступных 4 байт по 8 бит и кодировать 2^16^\*2^15^ или 32768 плоскостей. Но для совместимости оставили 17 плоскостей. 

Плоскость 0 с точками от 0000 и до FFFF назвали Основная многоязычная плоскость(Basic Multilingual Plane, BMP) за то, что она содержит в себе большинство современых языков и большое число образов(специальных символов), которые используются сегодня для записи в тексте книг и сообщений(почта или интернет). 

Плоскость 1 с точками от 10000 по 1FFFF назвали Дополнительная многоязычная плоскость (Supplementary Multilingual Plane, SMP). Она содержит в основном письменность уже умерших народов. Но встречаются и те, которые не используются современниками. Например Алфавит Шоу от 10450 по 1047F или [Письмо Бернарда Шоу](https://unicode-table.com/ru/blocks/shavian/){: target="_blank"}. Кроме того эта плоскость включает в себя наборы условных обозначений из музыки и математики.

Плоскости 2 и 3 - Дополнительная идеографическая плоскость(Supplementary Ideographic Plane, SIP) и Третичная идеографическая плоскость ( Tertiary Ideographic Plane, TIP). Содержат редко используемые иероглифы ККЯ и другие редко используемые китайские иероглифы.

Плоскости с 4 по 13 не используются. Это резерв для будующих поколений. 

Плоскость 14 с точками от E0000 по FFFFF - Специализированная дополнительная плоскость (Supplementary Special-purpose Plane, SSP). Содержит символы с особым назначением, такие как тэги и дополнения к вариативным селекторам. Сами Вариантные селекторы содержат 16 вариантов начертания и входят в Основную многоязычную плоскость с кодовыми точками с FE00 по FE0F.

Особо отметим следующие плоскости:

Плоскость 15 - Дополнительная область для частного использования — A (Supplementary Private Use Area-A, SPUA-A)
Плоскость 16 - Дополнительная область для частного использования — B (Supplementary Private Use Area-B, SPUA-B)

Юникод никогда не будет сопоставлять кодовые точки этих плоскостей: они для частного использования.

### Практика {: #praktika}

Последовательность бит из текста сообщения небходимо извлечь и отобразить на кодовые точки юникода. Но юникод не содежит стандарта преобразования бит в текст и обратно. Для этой цели используют один из стандартов кодирования (UTF — Unicode Transformation Format) : UTF-8, UTF-16 или UTF-32. Получая сообщение в символах юникода важно знать, какой из кодировок оно было закодировано. И передавая сообщения также важно уведомить получателя как оно закодировано. Было достигнуто соглашение о использовании символов (по 8 бит каждый) из начала сообщения, как маркера последовательности байтов или метки порядка байтов (Byte Order Mark, BOM).

| Кодировка   | BOM в шестнадцатеричном коде | BOM в десятичном коде |
|-------------|------------------------------|-----------------------|
| UTF-8       | EF BB BF                     | 239 187 191           |
| UTF-16 (BE) | FE FF                        | 254 255               |
| UTF-16 (LE) | FF FE                        | 255 254               |

Когда кодируем в UTF-16 следует договриться о порядке передачи байт из кодовой единицы размером в 2 байта:

- BE (Big-Endian) устанавливает порядок байт от старшего к младшему: ведущий байт - старший и замыкающий - младший. Число тысяча двести тридцать четыре будет записано слева на право, как это принято в арабской записи - 1234. В шестнадчатиричной записи это 04 D2. 
- LE (Little-Endian) устанавливает порядок байт от младшего к старшему.  

#### Стандарт UTF-16

Кодовой единицей является 2 байта. И кодовая точка может быть запсиана с использованием 2 или 4 байт.

##### Кодирование {: #kodirovanie16}

| Битовая запись кодовой точки | Формат кодировки значимый бит. <br>Порядок байт слева направо |
|------------------------------|---------------------------------------------------------------|
| xxxxxxxxxxxxxxxx             | xxxxxxxxxxxxxxxx                                              |
| 000uuuuuxxxxxxxxxxxxxxxx     | 110110wwwwxxxxxx 110111xxxxxxxxxx                             |

Где для `wwww` и `uuuuu` верно: `wwww = uuuuu - 1`.

Одна кодовая точка юникода, битовая запись которой длиннее 16 бит, кодируется 2 кодовыми точками в UTF-16. Эта пара точек называется суррогатной парой. Каждая кодовая точка из этой пары не имеет своего символьного представления и может быть показана в тесте символом � ( белым знаком вопроса внутри чёрного ромба).

Пусть кодовая точка C длинной более 16 бит. Обработка на языке C.

```
\\Определим следующие типы данных - беззнаковые целые числа в 16 и 32 бита
typedef unsigned int16 UTF16;
typedef unsigned int32 UTF32;
```
Вычислим HiSurrogate. Это старшая суррогатная кодовая точка для кодовой точки C:
```
const UTF16 HI_SURROGATE_START = 0xD800

UTF16 X = (UTF16) C;
UTF32 U = (C >> 16) & ((1 << 5) - 1);
UTF16 W = (UTF16) U - 1;
UTF16 HiSurrogate = HI_SURROGATE_START | (W << 6) | X >> 10;
```
Значения в X, U и W соответствуют своим обозначениям в таблице выше. 

Вычислим LoSurrogate. Это младшая суррогатная кодовая точка для кодовой точки C
```
const UTF16 LO_SURROGATE_START = 0xDC00

UTF16 X = (UTF16) C;
UTF16 LoSurrogate = (UTF16) (LO_SURROGATE_START | X & ((1 << 10) - 1));
```
Другой способ представить процесс кодирования:

У нас есть 21 бит для записи кодовой точки. Если для записи не хватает 16 бит, то процесс кодирования выглядит следующим образом:

1. Из значения кодовой точки вычитаем шестнадцатиричное число 10000 и получаем 20 битовую запись числа, котрую разделим на сташие 10 бит - yyyyyyyyyy и на младшие 10 бит - xxxxxxxxxx.

2. Старшая кодовая единица получается как сумма шестнадцатиричного числа D800 и старших бит yyyyyyyyyy. Итого 110110yyyyyyyyyy.

3. Младшая кодовая единица получается как сумма шестнадцатиричного числа DC00 и младших бит xxxxxxxxxx. Итого 110111xxxxxxxxxx.

##### Декодирование {: #dekodirovanie16}

```
UTF32 X = (HiSurrogate & ((1 << 6) -1)) << 10 | LoSurrogate & ((1 << 10) -1);
UTF32 W = (HiSurrogate >> 6) & ((1 << 5) - 1);
UTF32 U = W + 1;
UTF32 C = U << 16 | X;
```

##### Простой способ {: #prostoj_sposob}

Получение кодовых точек и их декодирование:
```
// constants
const UTF32 LEAD_OFFSET = 0xD800 - (0x10000 >> 10);
const UTF32 SURROGATE_OFFSET = 0x10000 - (0xD800 << 10) - 0xDC00;

// computations
UTF16 lead = LEAD_OFFSET + (codepoint >> 10);
UTF16 trail = 0xDC00 + (codepoint & 0x3FF);

UTF32 codepoint = (lead << 10) + trail + SURROGATE_OFFSET;
```

##### Внутри сообщения {: #vnutri_soobshcheniya}

Зачем такие сложности с суррогатными парами? В чём их смысл? Для любой кодировки важным моментом является работа с текстом и если мы знаем стандарт кодировки текста (как его кодировали) и получили прямой доступ к какой-то его части, то как понять находимся мы в начале кодовой точки, в её середине или в конце. Благодаря заголовкам (первым битам) мы можем это определить абсолютно точно. И суррогатные пары помогают отличить какой из них перед нами: старшый или младший. Используя порядок следования можно точно сказать о соседних кодовых точках: какие они и является это продолжением кодовой точки или частью другой кодовой точки или в точности кодовой точкой. И по этим данным восстановить кодовую точку юникода.

#### Стандарт UTF-8

Кодовой единицей является байт из 8 бит. Кодовая точка может быть записана с использованием от одного до четырёх байт: с использованием 8, 16, 24 или 32 бит.

##### Кодирование {: #kodirovanie8}

Как узнать, сколько байт требуется? Запишем кодовую точку в виде двоичного числа и определим сколько бит для этого потребуется. А дальше используем таблицу соответствия:

| Десятичные<br>кодовые точки | Битовая запись кодовой точки | Бит для <br>заголовка | Значимых<br>бит<br>u z y x | Байт<br>для<br>записи | Формат кодировки значимый бит. <br>Порядок байт слева направо |
|-----------------------------|------------------------------|-----------------------|----------------------------|-----------------------|---------------------------------------------------------------|
| 0-127                       | 00000000 0xxxxxxx            | 0                     | 7 х                        | 1                     | **0**{: style="color:#FF0000;background-color:#FFFFFF"}xxxxxxx                                                      |
| 128-2047                    | 00000yyy yyxxxxxx            | **2**{: style="color:#008000;background-color:#FFFFFF"}                     | 11=5y+6x                   | 2                     | **11**{: style="color:#008000;background-color:#FFFFFF"}**0**{: style="color:#FF0000;background-color:#FFFFFF"}yyyyy 1**0**{: style="color:#FF0000;background-color:#FFFFFF"}xxxxxx                                             |
| 2048-65535                  | zzzzyyyy yyxxxxxx            | **3**{: style="color:#008000;background-color:#FFFFFF"}                     | 16=4z+6y+6x                | 3                     | **111**{: style="color:#008000;background-color:#FFFFFF"}**0**{: style="color:#FF0000;background-color:#FFFFFF"}zzzz 1**0**{: style="color:#FF0000;background-color:#FFFFFF"}yyyyyy 1**0**{: style="color:#FF0000;background-color:#FFFFFF"}xxxxxx                                    |
| 65536-2097151               | 000uuuuu zzzzyyyy yyxxxxxx   | **4**{: style="color:#008000;background-color:#FFFFFF"}                     | 21=5u+4z+6y+6x             | 4                     | **1111**{: style="color:#008000;background-color:#FFFFFF"}**0**{: style="color:#FF0000;background-color:#FFFFFF"}uuu 1**0**{: style="color:#FF0000;background-color:#FFFFFF"}uuzzzz 1**0**{: style="color:#FF0000;background-color:#FFFFFF"}yyyyyy 1**0**{: style="color:#FF0000;background-color:#FFFFFF"}xxxxxx                           |

Первый бит **0**{: style="color:#FF0000;background-color:#FFFFFF"} делит последовательности бит в байте. Он указывает на заголовок(**биты слева**{: style="color:#008000;background-color:#FFFFFF"} от **0**{: style="color:#FF0000;background-color:#FFFFFF"} бита) и запись числа(биты справа от **0**{: style="color:#FF0000;background-color:#FFFFFF"} бита). Для одного байта первый бит всегда равен 0. Биты первого байта из заголовка указывают сколько байт используется для кодирования. Последующие биты как видно из формата всегда начинаются с 1 и используют последние 6 бит для записи числа.

Биты кодовой точки переносятся справа налево в указанный формат кодировки, начиная с последнего байта и оставшиеся не занятыми значимые биты записываются 0. 

##### Декодирование {: #dekodirovanie8}

Зная формат и количество байт для записи в этом формате записываем значимые биты по порядку слева на право и получем значение кодовой точки в виде двоичного числа.

##### Местоположение {: #mestopolozhenie}

Не важно где мы остановились в разборе сообщения. Всегда можно понять, сколько байт занимает кодовая точка (вернуться к первому байту заголовка) и продолжить процесс декодирования.

### Какой стандарт выбрать? {: #kakoj_standart_vybrat}

Для обработки строк символов для любой кодировки необходимы <a href="http://site.icu-project.org/" target="_blank">пакеты библиотек ICU</a>, так как группа знаков может быть использована для представления символа и простой учёт количества байт не позволяет сопоставить их символам текста.

#### Преимущества и недостаки кодировок UTF-8 и UTF-16 {: #preimushchestva_i_nedostaki_kodirovok}

В каждом станадрте кодирования Unicode значения кодовых единиц для кодовых единиц, которые только кодируют символы, ведущих единиц и замыкающих единиц не связаны. Знание этого имеет решающее значение для реализации.

Что требуется реализовать и что сделано в ICU:

1. Определить количество единиц для одной кодовой точки с использованием ведущей единицы. Это особенно важно для UTF-8, где на символ может быть до 4 байтов.

2. Установить границы. см. [Внутри сообщения](#vnutri_soobshcheniya) и [Местоположение](#mestopolozhenie). Если получен произвольный доступ к тексту, то всегда можно установить границы кодовой точки где мы находимся, используя небольшое количество команд.

3. Нет наложений по кодовым единицами. Для поиска строки A в строке B, никогда не получите ложное совпадение по кодовым точкам. Не нужно преобразовывать кодовые единицы в кодовые точки для поиска строк. Ложные совпадения никогда не встречаются, поскольку конец одной последовательности никогда не совпадает с началом другой последовательности.

4. Cледствием 2 является простой способ получения следующей или предыдущей кодовой точки. Это требует небольшого количества команд.

5. Симметрия UTF-16. Достаточно одной кодовой единицы, чтобы определить её роль: ведущая, замыкающая или в точности кодовая точка. Движение по тексту в любом направлении выполняется одинаково быстро и эффективно. 

6. Кодовые точки медленее индексируются, по сравнению с кодировками фиксированного размера. Нельзя получить 10-ую кодовую точку, пока не определены границы 9-ти предыдущих кодовых точек. ICU, как и большинство распространенных API, всегда индексирует по кодовым единицам. Он считает кодовые единицы, а не кодовые точки.

7. Очень быстрое преобразование между кодировками. Для сопоставления не используются табличные данные.

##### UTF-8 {: #utf_8}

- Это байтовая кодировка, обеспечивающая обратную совместимость с текстами в ASCII символах. 
- Без преобразований может быть использована в API и протоколах единицей информации в которых является байт. 
- Кодовая точка занимает от 1 до 4 байт.
    - Символы ASCII занимают на 50% меньше места в кодировке UTF-8, чем в UTF-16.
    - Для европейских языков будет значительная экономия в размере занимаемого места в байтах, чем в UTF-16.
    - Занимает на 50% больше места в байтах для языков Восточной Азии.
- Можно использовать двоичное сравнение строк UTF-8 на основе их байтов по порядку для сравнения значений кодовой точки.
- Получила широкое распространение: является стандартом де-факто для сайтов. Сайты, как и файлы это в том числе источники текстовой информации.

##### UTF-16 {: #utf_16}

- Упрощение обработки:
    - Кодовые точки в стандарте Юникод записаны 16-битовыми значениями.
    - 16-ти и 32-ух битовые значения это два базовых формата данных для кодирования юникода в ICU.
    - Не надо беспокоиться о переобразованиях, если разработка для Windows / Mac OS и используются в основном собственные вызовы API операционной системы. Подробнее см. [Software Using UTF-16](https://www.unicode.org/notes/tn12/#Software_16){: target="_blank"}
- Симметрия UTF-16. Достаточно одной кодовой единицы, чтобы определить её роль: ведущая, замыкающая или в точности кодовая точка. Движение по тексту в любом направлении выполняется одинаково быстро и эффективно.
- Кодовая единица 16 бит и кодовая точка занимет 1 или 2 единицы. 
    - Занимает на 50% меньше места в байтах для языков Восточной Азии, чем в UTF-8.
    - Для остальных языков занимает больше места.
- Нельзя использовать сравнение строк лексически на основе их 16-битных кодовых единиц по порядку для сравнения значений кодовой точки.
- При необходимости можно выполнить простую модификацию сравнения строк, которая по-прежнему позволяет проводить эффективные сравнения на основе кодовых единиц и делает их совместимыми со сравнениями кодовых точек.

### Полезные ссылки {: #poleznye_ssylki}

- <a href="https://unicode-table.com/ru/" target="_blank">Таблица символов Юникода</a>

- <a href="http://www.unicode.org/faq/utf_bom.html" target="_blank"> Frequently Asked Questions → UTF-8, UTF-16, UTF-32 & BOM</a> 

- <a href="https://unicode-org.github.io/icu/userguide/unicode.html" target="_blank">ICU Documentation → Unicode Basics</a>

- <a href="https://www.unicode.org/notes/tn12/" target="_blank">Unicode Technical Note #12: UTF-16 FOR PROCESSING</a>

- <a href="https://www.quora.com/When-should-UTF-16-encoding-be-preferred-over-UTF-8?q=preference%20utf-8%20">Quora → When should UTF-16 encoding be preferred over UTF-8?</a>
